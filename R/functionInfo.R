#' @name MethodsFunction-class
#' @title MethodsFunction-class
#' @keywords internal
#' @description MethodsFunction is an S3 class
setOldClass("MethodsFunction")

#' fcnS is an S4 class
#' fcnS includes a list of function and corresponding function S3/S4 method names info (MethodsFunction)
setClass("fcnS", slots = list(fcn = "list", fName = "MethodsFunction"))


#' functionInfo is an S4 class and a function to generate functionInfo object
#' functionInfo function 
#' @param typeof character, the result generated by typeof() function
#' @param S3S4  logical, whether the results of .S3methods() and .S4methods() exist
#' @param fcn function, the result shown by print.function() directly
#' @param fS3 fcnS object, the information of S3 methods
#' @param fS4 fcnS object, the information of S4 mehtods
#' 
#' @return a functionInfo object
#' @export
functionInfo = setClass(Class = "functionInfo", 
                        slots = list(typeof = "character", S3S4 = "logical", 
                                     fcn = "function", fS3 = "fcnS", fS4 = "fcnS"))


#' funCode function 
#' @name funCode
#' @param f a function name with or without quotation
#' @param pattern  regular expression to match the methods
#' @param envir environment to search
#' @keywords funcTools
#' @return A functionInfo object, containing the function type, 
#'         whether containing S3 or S4 methods, dirrect function source, 
#'         S3 methods info, and S4 methods info.
#' @examples 
#' # The source of print
#' funCode(print)
#' funCode("print")
#' # The source of funCode
#' funCode(funCode)
#' # The source of plot for data.frame
#' funCode("plot", "data.frame")
#' @description funCode function is to obtain the source code of an R function
#' @export
funCode = function(f = character(), pattern = NULL, 
                   envir = topenv(parent.frame())){
  # get a function name string (f) and a real function (fcn).
  if (is.character(f)) {
    fcn <- get(f, mode = "function", envir = envir, inherits = TRUE)
  } else if (is.function(f)){
    fcn = f
    f = deparse(substitute(f)) # not working outside the function
  }
  type = typeof(fcn)
  fNameS3 = suppressWarnings(.S3methods(f)) # S3 methods
  fNameS4 = .S4methods(f) # S4 methods
  # strsplit2 function
  strsplit2 = function(x, split, ...) {
    x <- as.character(x)
    n <- length(x)
    s <- strsplit(x, split = split, ...)
    nc <- unlist(lapply(s, length))
    out <- matrix("", n, max(nc))
    for (i in 1:n) {
      if (nc[i]) out[i, 1:nc[i]] <- s[[i]]
    }
    out
  }
  typeof = type
  S3S4 = c(S3 = length(fNameS3)>0, S4 = length(fNameS4)>0)
  fcnS3 = fcnS4 = list()
  if (S3S4[[1]]){
    names(fNameS3) = sub(paste0(f, "."), "", as.character(fNameS3))
    id = setNames(object = names(fNameS3), nm = names(fNameS3))
    fcnS3 = lapply(id, function(x) {
      getS3method(f = f, class = x, optional = TRUE, envir = envir)})
  }
  if (S3S4[[2]]){
    names(fNameS4) = fNameS4
    sig = strsplit2(strsplit2(fNameS4, "-")[,1], ",")[,-1, drop = F]
    id = setNames(object = 1:length(fNameS4), 
                  nm = apply(sig, 1, paste, collapse = ","))
    fcnS4 = lapply(id, function(x) getMethod(f, signature = sig[x,]))
    names(fNameS4) = names(id)
  }
  # filtering
  if (!is.null(pattern)){
    id3 = grep(pattern, fNameS3)
    id4 = grep(pattern, fNameS4)
    fcnS3 = fcnS3[id3]
    fcnS4 = fcnS4[id4]
  }
  # message
  if (is.element(typeof(fcn), c("special", "builtin"))){
    message(".Primitive and .Internal can be shown by pryr::show_c_source()\n")
  }
  resF = new("functionInfo", typeof = typeof, S3S4 = S3S4, fcn = fcn, 
             fS3 = new("fcnS", fcn = fcnS3, fName = fNameS3), 
             fS4 = new("fcnS", fcn = fcnS4, fName = fNameS4))
  return(resF)
}


#' @name show
#' @title show,functionInfo-method
#' @aliases  show,functionInfo-method
#' @param object an object of functionInfo class
#' @export
setMethod("show", signature = "functionInfo", function(object) {
  show(list(functionS3 = object@fS3@fName,
            functionS4 = object@fS4@fName))
})


