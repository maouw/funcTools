#' @name MethodsFunction-class
#' @title MethodsFunction-class
#' @keywords internal
#' @description MethodsFunction is an S3 class
setOldClass("MethodsFunction")

# fcnS is an S4 class
# fcnS includes a list of function and corresponding function S3/S4 method names info (MethodsFunction)
setClass("fcnS", slots = list(fcn = "list", fName = "MethodsFunction"))


# @describeIn functionInfo set a \code{functionInfo} class.
#' @title Generating functionInfo object\cr
#' @description FunctionInfo is an S4 class and a function to generate functionInfo object.
#' @param funName character, the function name.
#' @param typeof character, the result generated by `typeof`` function.
#' @param S3S4  logical, whether the results of \code{\link{.S3methods}}
#' and \code{\link{.S4methods}} exist.
#' @param fcn function, the result shown by `print.function` directly.
#' @param fS3 fcnS object, the information of S3 methods.
#' @param fS4 fcnS object, the information of S4 mehtods.
#' @return a functionInfo object
#' @import methods
#' @examples
#' \dontrun{
#' functionInfo()
#' }
#' @export
functionInfo = setClass(Class = "functionInfo",
                        slots = list(funName = "character", typeof = "character",
                                     S3S4 = "logical", fcn = "function",
                                     fS3 = "fcnS", fS4 = "fcnS"))


#' @title Finding function source code\cr
#' @description funCode function is to obtain the source code of an R function
#' @param f a function name with or without quotation
#' @param pattern  regular expression to match the object class.
#' @param envir environment to search
#' @return A \code{\link{functionInfo}} object, containing the function name,
#' function type, whether containing S3 or S4 methods, dirrect function source,
#' S3 methods info, and S4 methods info.
#' @import methods
#' @export
#' @examples {
#' \dontrun{
#' # The source of print
#' funCode(print)
#' funCode("print")
#'
#' # The source of funCode
#' funCode(funCode)
#'
#' # The source of plot for data.frame
#' funCode("plot", "data.frame")
#' }
#' }
funCode = function(f = character(), pattern = NULL,
                   envir = topenv(parent.frame())){
  # get a function name string (f) and a real function (fcn).
  if (is.character(f)) {
    fcn <- get(f, mode = "function", envir = envir, inherits = TRUE)
  } else if (is.function(f)){
    fcn = f
    f = deparse(substitute(f)) # not working outside the function
  }
  type = typeof(fcn)
  fNameS3 = suppressWarnings(.S3methods(f)) # S3 methods
  fNameS4 = methods::.S4methods(f) # S4 methods

  typeof = type
  S3S4 = c(S3 = length(fNameS3)>0, S4 = length(fNameS4)>0)
  fcnS3 = fcnS4 = list()
  if (S3S4[[1]]){
    names(fNameS3) = sub(paste0(f, "."), "", as.character(fNameS3))
    id = setNames(object = names(fNameS3), nm = names(fNameS3))
    fcnS3 = lapply(id, function(x) {
      getS3method(f = f, class = x, optional = TRUE, envir = envir)})
  }
  if (S3S4[[2]]){
    names(fNameS4) = fNameS4
    sig = strSplit(strSplit(fNameS4, "-")[,1], ",")[,-1, drop = F]
    id = setNames(object = 1:length(fNameS4),
                  nm = apply(sig, 1, paste, collapse = ","))
    fcnS4 = lapply(id, function(x) getMethod(f, signature = sig[x,]))
    names(fNameS4) = names(id)
  }
  # filtering
  if (!is.null(pattern)){
    id3 = grep(pattern, fNameS3)
    id4 = grep(pattern, fNameS4)
    fcnS3 = fcnS3[id3]
    fcnS4 = fcnS4[id4]
  }
  # message
  if (is.element(typeof(fcn), c("special", "builtin"))){
    message(".Primitive and .Internal can be shown by pryr::show_c_source()\n")
  }
  resF = new("functionInfo", funName = f,
             typeof = typeof, S3S4 = S3S4, fcn = fcn,
             fS3 = new("fcnS", fcn = fcnS3, fName = fNameS3),
             fS4 = new("fcnS", fcn = fcnS4, fName = fNameS4))
  return(resF)
}


# @name show
#' @title show,functionInfo-method\cr
#' @aliases  show,functionInfo-method
#' @param object an object of functionInfo class
#' @describeIn functionInfo Show the S3 method names in
#' object@@fS3 and S4 method names in object@@fS4
#' @export
setMethod("show", signature = "functionInfo", function(object) {
  # funName = as.character(substitute(object))
  cat(object@funName, "= ")
  if(length(object@fcn)){
    print(object@fcn)
  }
  show(list(functionS3 = object@fS3@fName,
            functionS4 = object@fS4@fName))
})


#' @title find dispatched functions for an object
#' @param f function name.
#' @param object the object that the function f is processing
#' @param envir the working environment
#' @export
#'
funDispatch = function(f, object, envir = topenv(parent.frame())){
  if (is.character(f)) {
    fcn <- get(f, mode = "function", envir = envir, inherits = TRUE)
  } else if (is.function(f)){
    fcn = f
    f = deparse(substitute(f)) # not working outside the function
  }
  funAll = funCode(f)
  # return(funAll)

  classes = NULL
  if (length(funAll@fS3@fcn) > 0){
    classes = c(classes, names(funAll@fS3@fcn))
    isDispatched3 = sapply(classes, function(x) is (object, x))
    isDispatched3 = isDispatched3[isDispatched3]
    if (length(isDispatched3) == 0 ){
      if ("default" %in% funAll@fS3@fcn){
        isDispatched3 = "default"
      } else {
        isDispatched3 = "originalFunction"
      }
    } else {
      isDispatched3 = names(isDispatched3)
    }
  } else {
    isDispatched3 = NULL
  }

  if (length(funAll@fS4@fcn) > 0){
    classes = c(classes, names(funAll@fS4@fcn))
    isDispatched4 = sapply(classes, function(x) is (object, x))
    isDispatched4 = names(isDispatched4[isDispatched4])
  } else {
    isDispatched4 = NULL
  }

  isDispatched = list(S3 = isDispatched3, S4 = isDispatched4)
  return(isDispatched)
}



#' @title apply either the dispatched S3 or S4 method of a function to an object
#' @param f function name.
#' @param object the object that the function f is processing.
#' @param S3 dispatched S3 method or "originalFunction".
#' @param S4 dispatched S4 method.
#' @param envir the working environment.
#' @examples
#' \dontrun{
#' funUse(print, "asdfasdfasd")
#' funUse(print, "asdfadsfasdf", S3 = "default")
#'
#' fit <- lm(sepal ~ Petal.Length + Petal.Width + Species, data = datasets::iris)
#' funUse(print, fit)
#' funUse(print, fit, S3 = "lm")
#' print.lm(fit)
#'
#' res = funUse(lm, object = sepal ~ Petal.Length + Petal.Width + Species, data = datasets::iris)
#' res
#' res = funUse(lm, object = sepal ~ Petal.Length + Petal.Width + Species,
#'              S3 = "originalFunction", data = datasets::iris)
#' res
#' lm(sepal ~ Petal.Length + Petal.Width + Species, data = datasets::iris)
#' }
#' @export

funUse = function(f, object, S3 = NULL, S4 = NULL,
                  envir = topenv(parent.frame()), ...){
  if (is.character(f)) {
    fcn <- get(f, mode = "function", envir = envir, inherits = TRUE)
  } else if (is.function(f)){
    fcn = f
    f = deparse(substitute(f)) # not working outside the function
  }
  funAll = funCode(f, envir = envir)
  desp = funDispatch(f, object, envir = envir)

  if (is.null(S3) & is.null(S4)){
    if (is.null(desp$S3) & is.null(desp$S4)){
      message("No dispatched function is found!")
      return(invisible(NULL))
    } else {
      if (!is.null(desp$S3)){
        if ("originalFunction" %in% desp$S3){
          message("No dispatching, '", f, "' function itself is used!")
          return(invisible(funAll@fcn(object, ...)))
        } else {
          message("For S3, you can specify S3 = one of the following words: \n")
          message(paste(desp$S3, collapse = " "), "\n")
          return(invisible(NULL))
        }
      }
      if (!is.null(desp$S4)){
        message("For S4, you can specify S4 = one of the following words: \n")
        message(paste(desp$S4, collapse = " "), "\n")
        return(invisible(NULL))
      }
    }
  } else if (!is.null(S3) && S3 %in% desp$S3){
    res = funAll@fS3@fcn[[S3]](object, ...)
  } else if (!is.null(S4) && S4 %in% desp$S4){
    res = funAll@fS4@fcn[[S4]](object, ...)
  } else {
    stop("No S3 or S4 method is found to be able to be dispatched!")
  }
    return(invisible(res))
}
